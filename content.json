{"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About","text":"seven777777 from sdust","link":"/about/index.html"}],"posts":[{"title":"hello-world","text":"Hello world！","link":"/2020/02/06/hello-world/"},{"title":"Cart树的原理及实现","text":"###CART在回归预测上的原理及实现 ####1.CART简介 CART是指分类回归树，Classfication And Regression Tree，缩写为CART,CART算法采用二分递归分割的技术将当前样本集分为两个子样本集，使得生成的每个非叶子节点都有两个分支。所以CART的结构是二叉树，CART可以处理连续型变量和离散型变量，利用训练数据递归的划分特征空间进行建树，用验证数据进行剪枝。 如果待预测分类是离散型数据，则CART生成分类决策树。 如果待预测分类是连续性数据，则CART生成回归决策树。 ####2.CART做回归预测在处理连续值时，CART采取回归的方式进行预测，假设X与Y分别是输入变量和输出变量，并且Y的取值是连续的，设训练集为D。$$D={(x_1,y_1),(x_2,y_2),(x_3,Y_3),…,(x_n,y_n)}$$CART的度量目标是，选取一个特征A和其对应的划分点s来划分数据集，使得划分出来的两个数据集的均方误差最小,不断的进行上述操作，当划分之后的均方差和划分之前的均方差之差的绝对值小于一个特定的阀值时，停止划分。$$min[min\\sum_{x_i\\in D_1(A,s)}(y_i-c_1)+min\\sum_{x_i\\in D_2(A,s)}(y_i-c_2)]$$其中$c_1$为$D_1$的样本输出均值，$c_2$为$D_2$的样本输出均值。在使用测试集时，采用均方误差作为预测误差。$$MSE=\\frac{1}{n}\\sum_{i=1}^n(predicted_i−label)^2$$其中$predicted_i$为预测值，$label$为实际预测值。 ####3.题目内容使用UCI公开数据集airfoil_self_noise（翼型自噪声），该数据集是NACA在2014年发布的一组关于0012翼型机在不同风洞速度和角度的数据，包含6个属性，分别是频率、角度、炫长、自由流速度、吸力侧位移厚度以及输出的y值低压声等级。该数据统计信息如下：| 数据 | 统计值 || ———— | ————– || example | 1503 || Training set | 1200 || Test set | 303 || Range of y | 103.38-140.987 || attributes | 6 | ####4.具体实现 结点的存储采用对象的方式进行，相比与字典的存储方式，虽代码量大但结构清晰。12345678910111213141516class Node: faNode = None #父节点 leftNode = None #左分支 rightNode = None #右分支 items = [] #划分到当前分支的数据集 attributes = [] #特征 label = 0 #划分这个节点的特征 num = 0 #划分的值或者输出的值 isLeaf = 0 #判断当前节点是否为叶节点 isLeft = 0 #判断当前节点是否为左分支，主要用于可视化 def __init__(self,items,attributes,label,num,isLeaf,): self.items = items self.attributes = attributes self.label = label self.num = num self.isLeaf = isLeaf 树的创建 找到最佳的待切分特征： 如果该节点不能再分，将该节点存为叶节点 执行二元切分 在右子树调用 createTree() 方法 在左子树调用 createTree() 方法 123456789101112131415161718192021222324252627282930313233343536373839404142def calCurVariance(tree,dataMat): ssum = 0;sum=0 for i in tree.items: ssum = ssum + dataMat[i][-1]*dataMat[i][-1] sum = sum + dataMat[i][-1] return sqrt(ssum-len(tree.items)*(sum/len(tree.items))*(sum/len(tree.items))),sum/len(tree.items)def createTree(tree,dataMat,Top): curVariance,y = calCurVariance(tree,dataMat) if curVariance &lt; 1e-5: tree.num = y tree.isLeaf=1 return best,tree.label,tree.num = findBestFeatureToSplit(tree,dataMat) if math.fabs(best-curVariance) &lt; Top: tree.isLeaf=1 tree.num = 0 for i in tree.items: tree.num = tree.num + dataMat[i][-1] tree.num = tree.num/len(tree.items) return tree.leftNode = Node([],[],'',0,0) tree.rightNode = Node([],[],'',0,0) tree.leftNode.faNode = tree tree.rightNode.faNode = tree for i in tree.items: if (dataMat[i][tree.label] &lt;= tree.num): tree.leftNode.items.append(i) else: tree.rightNode.items.append(i) for i in tree.attributes: tree.leftNode.attributes.append(i) tree.rightNode.attributes.append(i) tree.leftNode.isLeft=1 createTree(tree.leftNode,dataMat,Top) createTree(tree.rightNode,dataMat,Top) return calCurVariance()用于计算当前节点内部的均方差，当均方差接近于0时，说明这个里面的数据集纯度已经很高，不再进行划分。 createTree()用于创建树节点，这个函数有3个参数 tree : 当前节点 dataMat : 数据集矩阵 Top : 阀值cr","link":"/2020/02/27/Cart%E6%A0%91%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/"},{"title":"贝叶斯分类器","text":"地震预报是比较困难的一个课题,可以根据地震与生物异常反应之间的联系来进行研究。根据历史记录的统计,地震前一周内出现生物异常反应的概率为50%,而一周内没有发生地震但也出现了生物异常反应的概率为 10%。假设某 一个地区属于地震高发区,发生地震的概率为 20%。问:如果某日观察到明显的生物异常反应现象,是否应当预报一周内将发生地震? 设发生地震为$w_1$，不发生地震为$w_2$，当前出现的状态(出现了生物异常)为$x$。由题意可得$P(x|w_1)=0.5,P(x|w_2)=0.1,P(w_1)=0.2,P(w_2)=0.8$ 当前情况下$w_1$的概率为$P(w_1|x)=\\displaystyle\\frac{P(x|w_1)P(w_1)}{P(x)}$ 当前情况下$w_2$的概率为$P(w_2|x)=\\displaystyle\\frac{P(x|w_2)P(w_2)}{P(x)}$ $P(x)=\\sum_{j=1}^2P(x|w_j)P(w_j)=0.18$$P(w_1|x)=\\displaystyle\\frac{P(x|w_1)P(w_1)}{P(x)}=0.5556$$P(w_2|x)=\\displaystyle\\frac{P(x|w_2)P(w_2)}{P(x)}=0.4444$所以$P(w_1|x)=0.5556&gt;P(w_2|x)=0.4444$，故应当预报一周内将发生地震 对于上例中的地震预报问题,假设预报一周内发生地震,可以预先组织抗震 救灾,由此带来的防灾成本会有 2500 万元,而当地震确实发生时,由于地震造 成的直接损失会有 1000 万元;假设不预报将发生地震而地震又发生了,造成的 损失会达到 5000 万元。请问在观察到明显的生物异常反应后,是否应当预报一周内将发生地震? 根据题意可得：实际发生地震且预报发生地震的损失$\\lambda_1^1=3500$实际发生地震却不预报发生地震的损失$\\lambda_1^2=5000$实际不发生地震却预报发生地震的损失$\\lambda_2^1=2500$实际不发生地震且不预报发生地震的损失$\\lambda_2^2=0$ $R(\\alpha_1|X)$$=\\sum_{j=1}^2\\lambda_j^1P(w_j|x)$$=\\lambda_1^1P(w_1|x)+\\lambda_2^1P(w_2|x)$$=3500*\\displaystyle\\frac{P(x|w_1)P(w_1)}{P(x)}+2500*\\displaystyle\\frac{P(x|w_2)P(w_2)}{P(x)}$$=\\displaystyle\\frac{550}{P(x)}=3055.6$ $R(\\alpha_2|X)$$=\\sum_{j=1}^2\\lambda_j^2P(w_j|x)$$=\\lambda_1^2P(w_1|x)+\\lambda_2^2P(w_2|x)$$=5000*\\displaystyle\\frac{P(x|w_1)P(w_1)}{P(x)}$$=\\displaystyle\\frac{500}{P(x)}=2777.8$ 故$R(\\alpha_1|X)=3055.6&gt;R(\\alpha_2|X)=2777.8$，所以不应当预报一周内将发生地震","link":"/2020/02/19/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"},{"title":"在腾讯云服务器上部署hexo博客","text":"如何在腾讯云服务器上部署hexo博客本人在搭建过程中遇到了很多问题，因此写一个教程贴来总结一下 前期准备 本地环境 macOS Catalina 10.15 git node.js hexo 服务器端 腾讯云服务器 CentOS 7.6 64 Bit git node.js Nginx 服务器端部署 1.安装git1yum install git 2.安装node.js 1curl --silent --location https://rpm.nodesource.com/setup_5.x | bash - 使用 git --version 和 node --version 查看版本号 3.安装Nginx 1yuminstall nginx 使用 nginx -v查看版本号 4.配置Nginx 1vim /etc/nginx/nginx.conf 进行以下修改 1234567891011121314151617181920server { listen 80 default_server; listen [::]:80 default_server; server_name www.seven7.xyz seven7.xyz; #域名 root /home/hexo; #网站的根目录 自行创建 #以下不作修改 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } }配置完成后保存退出，使用nginx -t查看配置是否有错误。查看运行状态：systemctl status nginx，显示running表示成功运行 5.创建git用户123useradd gitchmod chmod 740 /etc/sudoersvim /etc/sudoers 在sudoers中找到下面内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 并且在下面增加 1git ALL=(ALL) ALL 修改权限 1chmod 400 /etc/sudoers 使用su git切换到git用户 1234567891011# 切换到git用户目录cd /home/git# 创建.ssh文件夹mkdir ~/.ssh# 创建authorized_keys文件并编辑vim ~/.ssh/authorized_keys# 如果你还没有生成公钥，那么首先在本地电脑中执行 cat ~/.ssh/id_rsa.pub | pbcopy生成公钥# 再将公钥复制粘贴到authorized_keys# 保存关闭authorized_keys后，修改相应权限chmod 600 ~/.ssh/authorized_keyschmod 700 ~/.ssh 本地测试是否可以进行免密码登陆 1ssh -v git@服务器IP地址 6.建立git裸库1234# 回到git目录cd /home/git# 使用git用户创建git裸仓库，以blog.git为例git init --bare blog.git 使用下列命令修改用户组权限 12sudo chown git:git -R /home/hexosudo chown git:git -R /home/git/blog.git 7.使用git-hooks同步网站根目录1vim ~/blog.git/hooks/post-receive 在里面输入下列内容 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f 保存退出后执行 chmod +x post-receive修改权限 到这里服务器端就已经配置完成了 本地端配置 打开hexo根目录下的_config.yml文件，进行下列配置 1234deploy: type: git repo: git@你的服务器IP:/home/git/blog.git branch: master 然后发布 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d","link":"/2020/02/06/%E5%9C%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/"},{"title":"MacOS终端美化","text":"MacOS自带的terminal终端没有命令高亮等功能，且界面单一，我们可以通过增加背景图和iterm2+zsh+oh～my～zsh进行美化 优化效果 配置方法1.增加背景图打开终端的偏好设置进行更改 2.下载安装iterm2官网下载 https://www.iterm2.com 将安装包移动到应用程序中进行安装，后面可以使用这个终端也可以使用MacOS原来的终端 3.将shell切换为zsh1chsh -s /bin/zsh 4.安装oh~my~zsh1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 5.安装字体库有些主题会要求特定的字体，Powerline字体: https://github.com/powerline/fonts 安装步骤如下： 12345678# clonegit clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts 安装好之后，选择一款Powerline字体了：iterm2 -&gt; Preferences -&gt; Profiles -&gt; Text -&gt; Font -&gt; Change Font 6.修改主题配置打开家目录下的.zshrc文件,找到主题配置的地方进行修改 1ZSH_THEME=&quot;michelebologna&quot; 之后重启终端 命令高亮zsh-syntax-highlighting地址：https://github.com/zsh-users/zsh-syntax-highlighting 12git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho &quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; ${ZDOTDIR:-$HOME}/.zshrc","link":"/2020/02/20/MacOS%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"},{"title":"爬虫入门之从当当网爬取图片","text":"1234567891011121314151617181920212223242526272829303132import reimport urllib.request#获取html页面def get_html(url): page = urllib.request.urlopen(url) html_a = page.read() #根据网页编码设置编码方式 return html_a.decode('gbk')def get_img(html): #封装正则表达式对象 reg = r'http://[^\\s]*?\\.jpg' imgre = re.compile(reg) #获取所有的图片url imglist = imgre.findall(html) x = 0 path = '/Users/seven7777777/code/' for imgurl in imglist: #将url以图片形式存储到本地 urllib.request.urlretrieve(imgurl, '{0}{1}.jpg'.format(path, x)) x = x + 1 return imglistif __name__ == '__main__': url = 'http://www.dangdang.com' #get_html(url) print (get_img(get_html(url)))","link":"/2020/02/20/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8%E4%B9%8B%E4%BB%8E%E5%BD%93%E5%BD%93%E7%BD%91%E7%88%AC%E5%8F%96%E5%9B%BE%E7%89%87/"}],"tags":[{"name":"数据挖掘","slug":"数据挖掘","link":"/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"MacOS终端美化","slug":"MacOS终端美化","link":"/tags/MacOS%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"}],"categories":[{"name":"作业","slug":"作业","link":"/categories/%E4%BD%9C%E4%B8%9A/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}